// Constants
    var ROUND_PRESETS = [10, 15, 20];
    var MAX_PLAYERS = 20;
    var MIN_PLAYERS = 2;

    // Initial state
    var initialGameState = {
      phase: 'setup',
      players: [],
      roundConfig: 20,
      isCustomRounds: false,
      currentRound: 1,
      rollCount: 0,
      bankTotal: 0,
      currentPlayerIndex: 0,
      lastRoll: null,
      lastRollEffect: null,
      history: [],
      stats: { totalSevens: 0, totalDoubles: 0, biggestBank: 0, biggestBankPlayer: null },
      settings: { virtualDice: true, darkMode: false }
    };

    // Game Reducer
    function gameReducer(state, action) {
      switch (action.type) {
        case 'ADD_PLAYER':
          if (state.players.length >= MAX_PLAYERS) return state;
          return Object.assign({}, state, {
            players: state.players.concat([{ id: Date.now(), name: action.name, cumulativeScore: 0, roundScore: null, hasBanked: false }])
          });
        case 'REMOVE_PLAYER':
          return Object.assign({}, state, { players: state.players.filter(function(p) { return p.id !== action.id; }) });
        case 'REORDER_PLAYERS':
          return Object.assign({}, state, { players: action.players });
        case 'SET_ROUND_CONFIG':
          return Object.assign({}, state, { roundConfig: action.rounds, isCustomRounds: action.isCustom || false });
        case 'TOGGLE_SETTING':
          var newSettings = Object.assign({}, state.settings);
          newSettings[action.setting] = !newSettings[action.setting];
          return Object.assign({}, state, { settings: newSettings });
        case 'START_GAME':
          return Object.assign({}, state, {
            phase: 'playing', currentRound: 1, rollCount: 0, bankTotal: 0, currentPlayerIndex: 0,
            lastRoll: null, lastRollEffect: null, history: [],
            players: state.players.map(function(p) { return Object.assign({}, p, { cumulativeScore: 0, roundScore: null, hasBanked: false }); }),
            stats: { totalSevens: 0, totalDoubles: 0, biggestBank: 0, biggestBankPlayer: null }
          });
        case 'ROLL': {
          var sum = action.die1 + action.die2;
          var isDoubles = action.die1 === action.die2;
          var isSeven = sum === 7;
          var isInSafeZone = state.rollCount < 3;
          var newRollCount = state.rollCount + 1;
          var newBankTotal = state.bankTotal;
          var rollEffect = null;
          var newPhase = state.phase;
          var newStats = Object.assign({}, state.stats);

          if (isSeven) {
            newStats.totalSevens++;
            if (isInSafeZone) { newBankTotal += 70; rollEffect = '+70'; }
            else { rollEffect = 'BUST!'; newPhase = 'roundEnd'; }
          } else if (isDoubles) {
            newStats.totalDoubles++;
            if (isInSafeZone) { newBankTotal += sum; rollEffect = '+' + sum; }
            else { newBankTotal *= 2; rollEffect = '\u00d72'; }
          } else { newBankTotal += sum; rollEffect = '+' + sum; }

          var nextPlayerIndex = state.currentPlayerIndex;
          var activePlayers = state.players.filter(function(p) { return !p.hasBanked; });
          if (activePlayers.length > 0 && newPhase !== 'roundEnd') {
            var currPlayer = state.players[state.currentPlayerIndex];
            var currentActiveIndex = activePlayers.findIndex(function(p) { return p.id === (currPlayer ? currPlayer.id : null); });
            var nextActiveIndex = (currentActiveIndex + 1) % activePlayers.length;
            nextPlayerIndex = state.players.findIndex(function(p) { return p.id === activePlayers[nextActiveIndex].id; });
          }

          return Object.assign({}, state, {
            rollCount: newRollCount, bankTotal: newBankTotal, lastRoll: { die1: action.die1, die2: action.die2 },
            lastRollEffect: rollEffect, currentPlayerIndex: nextPlayerIndex, phase: newPhase, stats: newStats,
            history: state.history.concat([{ type: 'roll', prevState: { bankTotal: state.bankTotal, rollCount: state.rollCount, currentPlayerIndex: state.currentPlayerIndex, stats: state.stats } }])
          });
        }
        case 'KEYPAD_INPUT': {
          var isInSafeZone = state.rollCount < 3;
          var newRollCount = state.rollCount + 1;
          var newBankTotal = state.bankTotal;
          var rollEffect = null;
          var newPhase = state.phase;
          var newStats = Object.assign({}, state.stats);

          if (action.isSeven) {
            newStats.totalSevens++;
            if (isInSafeZone) { newBankTotal += 70; rollEffect = '+70'; }
            else { rollEffect = 'BUST!'; newPhase = 'roundEnd'; }
          } else if (action.isDoubles) {
            newStats.totalDoubles++;
            newBankTotal *= 2; rollEffect = '\u00d72';
          } else { newBankTotal += action.sum; rollEffect = '+' + action.sum; }

          var nextPlayerIndex = state.currentPlayerIndex;
          var activePlayers = state.players.filter(function(p) { return !p.hasBanked; });
          if (activePlayers.length > 0 && newPhase !== 'roundEnd') {
            var currPlayer = state.players[state.currentPlayerIndex];
            var currentActiveIndex = activePlayers.findIndex(function(p) { return p.id === (currPlayer ? currPlayer.id : null); });
            var nextActiveIndex = (currentActiveIndex + 1) % activePlayers.length;
            nextPlayerIndex = state.players.findIndex(function(p) { return p.id === activePlayers[nextActiveIndex].id; });
          }

          return Object.assign({}, state, {
            rollCount: newRollCount, bankTotal: newBankTotal, lastRoll: null, lastRollEffect: rollEffect,
            currentPlayerIndex: nextPlayerIndex, phase: newPhase, stats: newStats,
            history: state.history.concat([{ type: 'roll', prevState: { bankTotal: state.bankTotal, rollCount: state.rollCount, currentPlayerIndex: state.currentPlayerIndex, stats: state.stats } }])
          });
        }
        case 'BANK_PLAYERS': {
          var newStats = Object.assign({}, state.stats);
          var newPlayers = state.players.map(function(p) {
            if (action.playerIds.indexOf(p.id) !== -1 && !p.hasBanked) {
              if (state.bankTotal > newStats.biggestBank) { newStats.biggestBank = state.bankTotal; newStats.biggestBankPlayer = p.name; }
              return Object.assign({}, p, { roundScore: state.bankTotal, hasBanked: true });
            }
            return p;
          });
          var allBanked = newPlayers.every(function(p) { return p.hasBanked; });
          var activePlayers = newPlayers.filter(function(p) { return !p.hasBanked; });
          var nextPlayerIndex = activePlayers.length > 0 ? newPlayers.findIndex(function(p) { return p.id === activePlayers[0].id; }) : state.currentPlayerIndex;
          return Object.assign({}, state, { players: newPlayers, phase: allBanked ? 'roundEnd' : state.phase, currentPlayerIndex: nextPlayerIndex, stats: newStats,
            history: state.history.concat([{ type: 'bank', prevPlayers: state.players, prevStats: state.stats }])
          });
        }
        case 'END_ROUND': {
          var newPlayers = state.players.map(function(p) { return Object.assign({}, p, { cumulativeScore: p.cumulativeScore + (p.roundScore || 0), roundScore: null, hasBanked: false }); });
          var isGameOver = state.currentRound >= state.roundConfig;
          return Object.assign({}, state, { players: newPlayers, phase: isGameOver ? 'gameOver' : 'playing', currentRound: isGameOver ? state.currentRound : state.currentRound + 1, rollCount: 0, bankTotal: 0, currentPlayerIndex: 0, lastRoll: null, lastRollEffect: null, history: [] });
        }
        case 'UNDO':
          if (state.history.length === 0) return state;
          var lastEntry = state.history[state.history.length - 1];
          var newHistory = state.history.slice(0, -1);
          if (lastEntry.type === 'roll') return Object.assign({}, state, { bankTotal: lastEntry.prevState.bankTotal, rollCount: lastEntry.prevState.rollCount, currentPlayerIndex: lastEntry.prevState.currentPlayerIndex, stats: lastEntry.prevState.stats, lastRoll: null, lastRollEffect: null, phase: 'playing', history: newHistory });
          if (lastEntry.type === 'bank') return Object.assign({}, state, { players: lastEntry.prevPlayers, stats: lastEntry.prevStats, phase: 'playing', history: newHistory });
          return state;
        case 'NEW_GAME_SAME_PLAYERS':
          return Object.assign({}, state, { phase: 'playing', currentRound: 1, rollCount: 0, bankTotal: 0, currentPlayerIndex: 0, lastRoll: null, lastRollEffect: null, history: [],
            players: state.players.map(function(p) { return Object.assign({}, p, { cumulativeScore: 0, roundScore: null, hasBanked: false }); }),
            stats: { totalSevens: 0, totalDoubles: 0, biggestBank: 0, biggestBankPlayer: null }
          });
        case 'NEW_GAME':
          return Object.assign({}, initialGameState, { settings: state.settings });
        default:
          return state;
      }
    }

    // Scroll lock hook
    function useScrollLock(locked) {
      useEffect(function() {
        if (locked) document.body.classList.add('modal-open');
        else document.body.classList.remove('modal-open');
        return function() { document.body.classList.remove('modal-open'); };
      }, [locked]);
    }

    // Animated number component
    function AnimatedNumber(props) {
      var value = props.value;
      var displayValueState = useState(value);
      var displayValue = displayValueState[0];
      var setDisplayValue = displayValueState[1];
      var prevValue = useRef(value);

      useEffect(function() {
        if (prevValue.current !== value) {
          var start = prevValue.current;
          var end = value;
          var duration = 400;
          var startTime = Date.now();
          var animate = function() {
            var elapsed = Date.now() - startTime;
            var progress = Math.min(elapsed / duration, 1);
            var eased = 1 - Math.pow(1 - progress, 3);
            setDisplayValue(Math.round(start + (end - start) * eased));
            if (progress < 1) requestAnimationFrame(animate);
          };
          requestAnimationFrame(animate);
          prevValue.current = value;
        }
      }, [value]);

      return React.createElement('span', null, displayValue);
    }

    // Die component
    function Die(props) {
      var value = props.value;
      var rolling = props.rolling;
      var pipPositions = {
        1: [[50, 50]], 2: [[25, 25], [75, 75]], 3: [[25, 25], [50, 50], [75, 75]],
        4: [[25, 25], [75, 25], [25, 75], [75, 75]], 5: [[25, 25], [75, 25], [50, 50], [25, 75], [75, 75]],
        6: [[25, 25], [75, 25], [25, 50], [75, 50], [25, 75], [75, 75]]
      };
      var pips = pipPositions[value] || [];
      return React.createElement('div', { className: 'die' + (rolling ? ' rolling' : '') },
        pips.map(function(pos, i) { return React.createElement('div', { key: i, className: 'pip', style: { left: pos[0] + '%', top: pos[1] + '%' } }); })
      );
    }